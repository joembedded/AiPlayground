<!DOCTYPE html>
<!-- http://localhost/wrk/ai/playground/sw/satzplay.html -->
<!-- Die Sprachausgabe mit GOOGLE-API ist sehr gut, aber wenig Betonung und nur aucf CHROME
Hier via OpenAI TTS API mit Satzaufteilung um lange Texte zu verarbeiten. 
satzplay zerlegt den Text in Sätze, Satzübergange sind evtl. nicht optimal, daher mglst lange Sätze 
bauen. Per URL sind <2k save, hier in jedem fall die Hightech-Lösung. ANsonsten würde einfaches GET
wohl auch schon reichen.
-->
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/allg.css">
    <title>Text zu Audio</title>
</head>

<body>
    <h1>Text zu Audio Converter</h1>
    <label for="input">Eingabetext:</label>
    <textarea id="input" placeholder="Geben Sie hier Ihren Text ein...">
Wenn die Kinder artig sind,
kommt zu ihnen das Christkind.
wenn sie ihre Suppe essen
und das Brot auch nicht vergessen,
wenn sie, ohne Lärm zu machen,
still sind bei den Siebensachen,
beim Spaziergehn auf den Gassen,
von Mama sich führen lassen,
bringt es ihnen Guts genug
und ein schönes Bilderbuch.

Sieh einmal, hier steht er,
pfui, der Struwwelpeter!
An den Händen beiden
ließ er sich nicht schneiden
seine Nägel fast ein Jahr.
Kämmen ließ er nicht sein Haar.
Pfui, ruft da ein jeder:
Garstger Struwwelpeter!

    </textarea>
    <label>Voice:
        <select id="voiceSelect">
            <option value="narrator_m_jack">narrator_m_jack</option>
            <option value="narrator_m_vilo">narrator_m_vilo</option>
            <option value="narrator_f_jane">narrator_f_jane</option>
        </select>
    </label>

    <button id="processButton" onclick="processText()">Text verarbeiten</button>
    &nbsp; <span id="audioStatus">???</span>

    <audio id="audioPlayer" controls></audio>


    <label for="output">Ausgabe:</label>
    <textarea id="output" readonly wrap="off"></textarea>

    <script>
        // *** Muss mit keys.inc.php uebereinstimmen *todo* extern holen ***
        const API_PASSWORD = 'Leg1310LX'; //  
        // *** Muss mit keys.inc.php uebereinstimmen *todo* extern holen ***

        let audioCache = [];
        let isProcessing = false;
        let isLoading = false;
        let audioUrl = null;
        let pollInterval;
        // für GET <2000 Zeichen safe, <4000: 'okÄ, >4000 evtl. Probleme
        const maxSentenceLength = 4000; // Maximale Satzlänge in Zeichen fuer die API
        const splitShortSentencesFlag = false; // true



        const audioStatus = document.getElementById('audioStatus');
        const audioPlayer = document.getElementById('audioPlayer');
        // Abspielen sobald möglich
        audioPlayer.oncanplay = function () {
            audioPlayer.play().catch(error => {
                addOutput('Autoplay prevented: ' + error);
            });
        }
            // Alte URL freigeben wenn Audio beendet ist
            audioPlayer.onended = function () {
                if(audioUrl) {
                    URL.revokeObjectURL(audioUrl);
                    audioUrl = null;
                }
                isLoading = false;
            };


        // Poll-Funktion starten
        function startPolling() {
            if (!pollInterval) {
                pollInterval = setInterval(checkAndPlayAudio, 100);
            }
        }

        // Prüfen und Audio abspielen
        function checkAndPlayAudio() {
            // canplay feuert ab HAVE_FUTIRE_DATA
            const STATS = ["HAVE_NOTHING", "HAVE_METADATA", "HAVE_CURRENT_DATA", "HAVE_FUTURE_DATA", "HAVE_ENOUGH_DATA"];
            audioStatus.textContent = `State:${STATS[audioPlayer.readyState]} Paused:${audioPlayer.paused} Ended:${audioPlayer.ended} CacheLen:${audioCache.length}`;

            // Wenn audioCache leer ist, nichts tun
            if (audioCache.length === 0 || isLoading) {
                return;
            }

            // Wenn Audio-Element gerade spielt, warten
            if (!audioPlayer.paused && !audioPlayer.ended) {
                return;
            }

            // Nächstes Audio aus Cache holen und abspielen
            const audioBlob = audioCache.shift();
            audioUrl = URL.createObjectURL(audioBlob);
            audioPlayer.src = audioUrl;
            audioPlayer.play().then(() => {
                addOutput(`Play - verbleibende Dateien: ${audioCache.length}`, 'success');
            }).catch(err => {
                addOutput('Fehler beim Abspielen: ' + err.message, 'error');
            });

        };


        // Text in Sätze zerlegen
        function splitIntoSentences(text) {
            let currentSentence = '';
            const sentences = [];
            // Satz zur Liste hinzufügen mit Längenbegrenzung
            function addSentence(sentence) {
                sentence = sentence.trim();
                if (sentence.length > maxSentenceLength) { // Überlänge begrenzen
                    sentence = sentence.substring(0, maxSentenceLength) + ' ...';
                }
                if (sentence.length > 0) sentences.push(sentence);
            }
            // Die eigentliche Zerlegung
            if (splitShortSentencesFlag) { // In kleine Saetze
                const END_CHARS = ['.', '!', '?', ':'];
                for (let i = 0; i < text.length; i++) {             // Sätze anhand von '.', '!', '?' oder ':' trennen
                    currentSentence += text[i];
                    if (END_CHARS.includes(text[i])) {
                        addSentence(currentSentence.trim());
                        currentSentence = '';
                    }
                }
            } else { // in So viel wie möglich, aber Saetze
                const END_CHARS_PLUS = ['.', '!', '?', ':', ';', ',', ' '];
                while (text.length > maxSentenceLength) {
                    let splitPos = -1;
                    for (const char of END_CHARS_PLUS) {
                        const pos = text.lastIndexOf(char, maxSentenceLength);
                        if (pos > splitPos) {
                            splitPos = pos;
                            break;
                        }
                    }
                    if (splitPos === -1) splitPos = maxSentenceLength; // Kein Satzende gefunden, harte Grenze
                    let sentence = text.substring(0, splitPos + 1);
                    addSentence(sentence.trim());
                    text = text.substring(splitPos + 1).trim();
                }
            }
            // Restlichen Text hinzufügen, falls vorhanden
            addSentence(currentSentence.trim());
            if (text.length > 0) addSentence(text);
            return sentences;
        }

        // Ausgabe hinzufügen
        function addOutput(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const className = type;
            output.value += `[${timestamp}] ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        // Ausgabe löschen
        function clearOutput() {
            document.getElementById('output').value = '';
        }

        // Audio für einen Satz abrufen
        async function fetchAudioForSentence(sentence, voice) {
            addOutput(`Satz: '${sentence.substring(0, 50)}${sentence.length > 50 ? '...' : ''}' wird verarbeitet...`, 'info');

            const methodGET = (audioPlayer.paused==true)&&(audioCache.length==0)&&(isLoading==false);

            const formData = new FormData();
            if (!methodGET) {
                formData.append('text', sentence);
                formData.append("voice", voice);
                formData.append('apipw', API_PASSWORD);
                formData.append('stream', '1');
            } else {
                var url = `./api/oai_tts.php?text=${encodeURIComponent(sentence)}&voice=${encodeURIComponent(voice)}&apipw=${encodeURIComponent(API_PASSWORD)}&stream=1`;
                isLoading = true;
            }
            try {
                if (methodGET) {
                    addOutput(`Lade Audio via GET/src...`, 'info');
                    audioPlayer.src = url;
                    audioPlayer.load();
                } else {
                    addOutput(`Lade Audio via POST/cache...`, 'info');
                    var response = await fetch("./api/oai_tts.php", { method: "POST", body: formData });
                    const contentType = response.headers.get('content-type');

                    // Prüfen ob Audio oder Fehler
                    if (response.ok && contentType && contentType.includes('audio')) {
                        const audioBlob = await response.blob();
                        audioCache.push(audioBlob);
                        addOutput(`Audio für Satz geladen: "${sentence.substring(0, 50)}${sentence.length > 50 ? '...' : ''}"`, 'success');
                    } else {
                        // Fehler als Text oder JSON
                        const errorText = await response.text();
                        try {
                            const errorJson = JSON.parse(errorText);
                            addOutput(`ERROR(JSON): ${JSON.stringify(errorJson)}`, 'error');
                        } catch {
                            addOutput(`ERROR(TEXT): ${errorText.substring(0, 100)}`, 'error');
                        }
                    }
                }
            } catch (error) {
                addOutput(`ERROR(Server) Scentence:"${sentence.substring(0, 50)}...": ${error.message}`, 'error');
            }
        }

        // Hauptfunktion zum Verarbeiten des Textes
        async function processText() {
            if (isProcessing) {
                return;
            }

            const inputText = document.getElementById('input').value.trim();

            if (inputText.length === 0) {
                addOutput('Kein Text eingegeben!', 'error');
                return;
            }

            isProcessing = true;
            document.getElementById('processButton').disabled = true;
            clearOutput();


            // Text normalisieren: Newlines und Tabs in Leerzeichen umwandeln
            const normalizedText = inputText.replace(/[\n\r\t]+/g, ' ');
            // Text in Sätze zerlegen
            const sentences = splitIntoSentences(normalizedText);
            addOutput(`Text in ${sentences.length} Sätze zerlegt`, 'info');

            // Jeden Satz verarbeiten
            const selectedVoice = document.getElementById("voiceSelect").value;


            for (let i = 0; i < sentences.length; i++) {
                await fetchAudioForSentence(sentences[i], selectedVoice);
            }


            addOutput('Alle Sätze verarbeitet', 'success');
            isProcessing = false;
            document.getElementById('processButton').disabled = false;
        }

        // Polling beim Laden der Seite starten
        window.addEventListener('load', function () {
            startPolling();
        });
    </script>
</body>

</html>